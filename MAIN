
long counter_sensor;
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
#define buttom_esquerda B00000010
#define buttom_direita B00000001
#define n_sensor 2


typedef void (* Event)(void*); //function pointer prototype to a function which takes an 'int' an returns 'void'


struct Events {   
  Event *enter;      
  Event *execute;      
  Event *leave;      
  Event *refresh;      
}; 




class Page{
private:
  Event onEnter;
  Event onExecute;
  Event onLeave;
  Event onRefresh;
public:
  int option;
  Page(Event e, Event a, Event b,Event c){
    this->onEnter = e;
    this->onExecute = a;
    this->onLeave = b;
    this->onRefresh = c;      
  };
  void enter(void){
    if(this->onEnter)this->onEnter(args);
  };

  void leave(void){
    if(this->onLeave)this->onLeave(args);
  };  
  void execute(void){
    if(this->onExecute)this->onExecute(args);
  };      
  void refresh(void){
    if(this->onRefresh)this->onRefresh(args);
  };  
  void setArgs(void * args){

    this->args = args;
  };    
  void add(Page * p){
    if(!this->right){
      this->right = p;
      p->left = this;
    }
    else
      this->right->add(p);
  };
  void addSubMenu(Page * p){
    p->parent = this;
    if(!this->child)
      this->child = p;
    else
      this->child->add(p);
  };
  void * args;
  Page * right;
  Page * left;
  Page * parent;
  Page * child;    

}; 
class Menu{
  Page * atual;

  long time_refresh;
public:
  Page * root;
  void add(Page * p){
    if(!this->root){
      this->root = p;
      this->atual = p;
      return;
    }
    this->atual->add(p);
  } 
  void addSubMenu(Page * p){
    this->atual->addSubMenu(p);
  } 


  void execute()
  {

    this->atual->execute();
    if(millis() - time_refresh < 500)
      return;
    this->atual->refresh();
    time_refresh = millis();
  }
  void init(void)
  {
    this->atual = this->root;
    this->atual->enter();
  }

  void enter(void){
    if(!this->atual->child)
      return;
    this->atual = this->atual->child;
    this->atual->enter();       

  }
  void back(void){
    if(!this->atual->parent)
      return;
    this->atual->leave();      
    this->atual = this->atual->parent;
    this->atual->enter();

  }
  void next(void){
    if(!this->atual->right)
      return;
    this->atual = this->atual->right;
    this->atual->enter();       
  }

  void prev(void){
    if(!this->atual->left)
      return;
    this->atual = this->atual->left;
    this->atual->enter();


  }
};


int temp[n_sensor]={
  0,0};
int s_min[n_sensor]={
  90,10};
int s_max[n_sensor]={
  100,120};

LiquidCrystal_I2C lcd(0x20,20,4);  // set the LCD address to 0x20 for a 16 chars and 2 line display

int sensor = 0;

Menu m;

struct parameters_sensor_page {
  int * m;
  int * mx;
  int number;
  int options;
};


//   main -------- config sensor 1 ------------ config sensor 2
//                       |                            |
//                     editar                       editar

Page p(&mainMenu,&main_execute,NULL,&mainRefresh);




Page config1(&page,&main_execute,NULL,NULL);
Page configSensors1(&enterConfigSensor,&configExecute,&configLeave,&configRefresh);
Page editSensor1(NULL,&editExecute,NULL,NULL);
parameters_sensor_page sensor1;

Page config2(&page,&main_execute,NULL,NULL);
Page configSensors2(&enterConfigSensor,&configExecute,&configLeave,&configRefresh);
Page editSensor2(NULL,&editExecute,NULL,NULL);
parameters_sensor_page sensor2;

void setup()
{
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();

  menu_config();

  attachInterrupt(1, selects, FALLING );
  attachInterrupt(0, buttom, CHANGE);
}



inline void menu_config(){

  sensor1.m = &s_min[0];
  sensor1.mx = &s_max[0];  
  sensor2.m = &s_min[1];
  sensor2.mx = &s_max[1];
  sensor1.number = 1;
  sensor2.number = 2;
  sensor1.options = 0;
  sensor2.options = 0;  
  m.add(&p);
  m.add(&config1);
  m.add(&config2);
  config1.setArgs(&sensor1);
  config2.setArgs(&sensor2);
  configSensors1.setArgs(&sensor1);
  configSensors2.setArgs(&sensor2);
  editSensor1.setArgs(&sensor1);
  editSensor2.setArgs(&sensor2);  
  config1.addSubMenu(&configSensors1);  
  config2.addSubMenu(&configSensors2);    
  configSensors1.addSubMenu(&editSensor1);  
  configSensors2.addSubMenu(&editSensor2);    
  m.init(); 

}



int decoder;
void loop()
{
  read_sensor();
  m.execute();
  if (Serial.available() > 0) {
    Serial.println(*(*(parameters_sensor_page*)m.root->args).m);
    char a =Serial.read();
    Serial.println(*(*(parameters_sensor_page*)m.root->args).m);
    Serial.print(a);
    switch(a){
    case 'w':
      decoder = buttom_esquerda;
      break;
    case 's':
      decoder = buttom_direita;
      break;
    case 'e':
      decoder = 3;
      break;
    case 'b':
      decoder = 4;
      break;        
    }
    Serial.println(*(*(parameters_sensor_page*)m.root->args).m);
  }

}

void read_sensor(){
  if(millis() - counter_sensor < 300 *6)
    return;
  for(int i = 0 ; i < n_sensor ; i++){
    temp[i] = temp[i] >= 1000 ? random(temp[i]-5,temp[i]): temp[i] < -90? random(temp[i],temp[i]+5): random(temp[i]-5,temp[i]+5);
  }
  counter_sensor = millis();
}


void mainMenu(void* p)
{
  sensor = 0;
  lcd.clear();
  lcd.print("       Status       ");
  lcd.setCursor(0,1);
  lcd.print(" 1: 0.0");
  lcd.setCursor(0,2);
  lcd.print(" 2: 0.0");
}
void main_execute(void* p){
  if(!decoder)
    return;
  switch(decoder){    
  case buttom_direita:
    m.next();
    break;
  case buttom_esquerda:
    m.prev();
    break;
  case 3:
    m.enter();
    break;
  case 4:
    m.back();
    break;
  }
  decoder = 0;
}
void mainRefresh(void* p){

  lcd.setCursor(3,1);
  if(temp[0] >= 0)
    lcd.print(" ");      
  lcd.print((float)temp[0]/10,1);
  lcd.setCursor(3,2);
  if(temp[1] >= 0)
    lcd.print(" ");      
  lcd.print((float) temp[1]/10,1);

}
void page(void* p)
{
  parameters_sensor_page s = *(parameters_sensor_page*)p;
  lcd.setCursor(0,0);
  lcd.print("<   Configuracao   >");
  lcd.setCursor(0,1);
  lcd.print("Sensor:");
  lcd.print(s.number,DEC);
  lcd.setCursor(9,1);
  lcd.print("          ");
  lcd.setCursor(0,2);
  lcd.print("                    ");
  lcd.setCursor(0,3);
  lcd.print("                    ");
}

void configLeave(void* p)
{

}

void configRefresh(void* p)
{


  //lcd.clear();
}


void enterConfigSensor(void* p)
{
  parameters_sensor_page s = *(parameters_sensor_page*)p;
  lcd.setCursor(13,1);  
  lcd.print("voltar");  
  lcd.setCursor(0,2);
  lcd.print(" min            max ");
  lcd.setCursor(0,3);

  if(*s.m > 0)
      lcd.print(" ");   


  lcd.print((float)*s.m/10,1);
  lcd.setCursor(15,3);
    if(*s.m > 0)
      lcd.print(" ");   

  lcd.print((float)*s.mx/10,1);
}

void configExecute(void* p)
{
  parameters_sensor_page * s = (parameters_sensor_page*)p;
  if(!decoder && s->options)
    return;
  switch(decoder){    
  case buttom_direita:

    s->options = ++s->options > 3? 1:s->options;

    break;
  case buttom_esquerda:

    s->options = --s->options <= 0 ? 3:s->options;

    break;
  case 3:
    decoder = 0;
    if(s->options == 3){
      m.back();  
      s->options =0 ;
    }
    else
      m.enter();
    return; 
    break;  
  case 4:
    m.back();
    return;    
    break;
  }
  decoder = 0;

  lcd.setCursor(12,1); 
  lcd.print(" ");
  lcd.setCursor(0,2); 
  lcd.print(" ");
  lcd.setCursor(15,2); 
  lcd.print(" ");

  switch(s->options){
  case 1:
    lcd.setCursor(0,2); 
    lcd.print(">");
    break;
  case 2  :
    lcd.setCursor(15,2); 
    lcd.print(">");     
    break;
  default:
    s->options = 3;
    lcd.setCursor(12,1); 
    lcd.print(">");

  }
}

void editExecute(void* p)
{
  parameters_sensor_page * s = (parameters_sensor_page*)p;
  if(!decoder)
    return;
  switch(decoder){    
  case buttom_direita:
    if(s->options == 1)
      *s->m += 1;      
    else
      *s->mx += 1;      
    break;
  case buttom_esquerda:
    if(s->options == 1)
      *s->m-=1;      
    else
      *s->mx-=1;      
    break;
  case 3:
    m.back();  
    decoder = 0;
    return;    
    break;
  }

  decoder = 0;

  if(s->options == 1){
    lcd.setCursor(0,3);
     if(*s->m > 0)
      lcd.print(" ");   
    lcd.print((float)*s->m/10,1);
  }  else{
    lcd.setCursor(15,3); 
     if(*s->mx > 0)
      lcd.print(" ");
    lcd.print((float)*s->mx/10,1);      
  }
      lcd.print(" ");
}



long debounce;
void buttom()
{
  if(millis() - debounce > 300){
    if (digitalRead(4) == digitalRead(2))
    {
      decoder = 1; //if encoder channels are the same, direction is CW
    }
    else
    {   
      decoder = 2; //if they are not the same, direction is CCW
    } 
    debounce = millis(); 
  } 
}

void selects(void){ 
  if(millis() - debounce > 500){
    decoder = 3;
    debounce = millis(); 
  }
}



